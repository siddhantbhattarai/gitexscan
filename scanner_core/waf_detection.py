"""WAF (Web Application Firewall) detection module."""

import re
from typing import Optional, Dict, List, Tuple
from dataclasses import dataclass

import requests

from .utils import safe_request, create_session


@dataclass
class WAFInfo:
    """Information about detected WAF."""
    name: str
    detected: bool
    confidence: str  # "high", "medium", "low"
    indicators: List[str]


# WAF detection signatures
WAF_SIGNATURES = {
    "cloudflare": {
        "headers": ["cf-ray", "cf-cache-status", "__cfduid"],
        "cookies": ["__cfduid", "__cf_bm"],
        "body_patterns": ["cloudflare", "attention required", "ray id"],
        "server": ["cloudflare"],
    },
    "aws_waf": {
        "headers": ["x-amzn-requestid", "x-amz-cf-id"],
        "body_patterns": ["aws", "request blocked"],
    },
    "akamai": {
        "headers": ["x-akamai-transformed", "akamai-grn"],
        "server": ["akamaighost", "akamai"],
    },
    "sucuri": {
        "headers": ["x-sucuri-id", "x-sucuri-cache"],
        "body_patterns": ["sucuri website firewall", "sucuri cloudproxy"],
        "server": ["sucuri"],
    },
    "imperva": {
        "headers": ["x-iinfo"],
        "cookies": ["incap_ses", "visid_incap"],
        "body_patterns": ["incapsula", "imperva"],
    },
    "f5_big_ip": {
        "headers": ["x-wa-info"],
        "cookies": ["bigipserver", "ts"],
        "server": ["big-ip", "bigip"],
    },
    "modsecurity": {
        "headers": ["x-mod-security"],
        "body_patterns": ["mod_security", "modsecurity", "not acceptable"],
        "server": ["modsecurity"],
    },
    "wordfence": {
        "body_patterns": ["wordfence", "this response was generated by wordfence"],
    },
    "barracuda": {
        "headers": ["barra_counter_session"],
        "cookies": ["barra_counter_session"],
        "body_patterns": ["barracuda"],
    },
    "fortiweb": {
        "headers": ["fortiwafsid"],
        "cookies": ["cookiesession1"],
    },
    "nginx_waf": {
        "body_patterns": ["nginx", "403 forbidden"],
        "server": ["nginx"],
    },
}


def detect_waf(url: str, timeout: int = 10) -> WAFInfo:
    """
    Detect if a website is protected by a WAF.
    
    Args:
        url: URL to check
        timeout: Request timeout
        
    Returns:
        WAFInfo with detection results
    """
    session = create_session()
    indicators_found = []
    detected_wafs = {}
    
    # Make a normal request
    response, error = safe_request(url, session, timeout)
    
    if error or response is None:
        return WAFInfo(
            name="unknown",
            detected=False,
            confidence="low",
            indicators=[f"Error: {error}"]
        )
    
    # Check each WAF signature
    for waf_name, signatures in WAF_SIGNATURES.items():
        matches = 0
        waf_indicators = []
        
        # Check headers
        if "headers" in signatures:
            for header in signatures["headers"]:
                if header.lower() in [h.lower() for h in response.headers.keys()]:
                    matches += 1
                    waf_indicators.append(f"Header: {header}")
        
        # Check server header
        if "server" in signatures:
            server = response.headers.get("server", "").lower()
            for s in signatures["server"]:
                if s.lower() in server:
                    matches += 2  # Server header is strong indicator
                    waf_indicators.append(f"Server: {server}")
                    break
        
        # Check cookies
        if "cookies" in signatures:
            cookies = [c.name.lower() for c in response.cookies]
            for cookie in signatures["cookies"]:
                if cookie.lower() in cookies:
                    matches += 1
                    waf_indicators.append(f"Cookie: {cookie}")
        
        # Check body patterns
        if "body_patterns" in signatures:
            body_lower = response.text.lower()
            for pattern in signatures["body_patterns"]:
                if pattern.lower() in body_lower:
                    matches += 1
                    waf_indicators.append(f"Body pattern: {pattern}")
        
        if matches > 0:
            detected_wafs[waf_name] = {
                "matches": matches,
                "indicators": waf_indicators
            }
    
    # Try triggering WAF with suspicious request
    suspicious_payloads = [
        "/.git/HEAD",
        "/?id=1' OR '1'='1",
        "/../../../etc/passwd",
        "/<script>alert(1)</script>",
    ]
    
    for payload in suspicious_payloads:
        test_url = url.rstrip('/') + payload
        resp, _ = safe_request(test_url, session, timeout)
        
        if resp and resp.status_code in [403, 406, 429, 503]:
            # Check response for WAF indicators
            body_lower = resp.text.lower()
            for waf_name, signatures in WAF_SIGNATURES.items():
                if "body_patterns" in signatures:
                    for pattern in signatures["body_patterns"]:
                        if pattern.lower() in body_lower:
                            if waf_name not in detected_wafs:
                                detected_wafs[waf_name] = {"matches": 0, "indicators": []}
                            detected_wafs[waf_name]["matches"] += 2
                            detected_wafs[waf_name]["indicators"].append(f"Block page: {pattern}")
    
    # Determine result
    if not detected_wafs:
        return WAFInfo(
            name="none",
            detected=False,
            confidence="medium",
            indicators=[]
        )
    
    # Find WAF with most matches
    best_match = max(detected_wafs.items(), key=lambda x: x[1]["matches"])
    waf_name = best_match[0]
    match_count = best_match[1]["matches"]
    all_indicators = best_match[1]["indicators"]
    
    # Determine confidence
    if match_count >= 3:
        confidence = "high"
    elif match_count >= 2:
        confidence = "medium"
    else:
        confidence = "low"
    
    return WAFInfo(
        name=waf_name,
        detected=True,
        confidence=confidence,
        indicators=all_indicators
    )


def check_waf_bypass(url: str, waf_info: WAFInfo) -> Dict[str, bool]:
    """
    Check potential WAF bypass techniques.
    
    Args:
        url: Target URL
        waf_info: Detected WAF information
        
    Returns:
        Dict of bypass technique -> success
    """
    session = create_session()
    bypasses = {}
    
    # Test direct IP access (if available)
    # This would require DNS lookup which we skip for simplicity
    
    # Test different encodings
    test_path = "/.git/HEAD"
    encodings = {
        "normal": test_path,
        "double_encode": "/.git%252fHEAD",
        "unicode": "/.%67%69%74/HEAD",
        "null_byte": "/.git/HEAD%00.html",
        "path_traversal": "/valid/../.git/HEAD",
    }
    
    for name, path in encodings.items():
        test_url = url.rstrip('/') + path
        resp, _ = safe_request(test_url, session, timeout=10)
        
        if resp and resp.status_code == 200:
            # Check if we got actual git content
            if "ref:" in resp.text or "[core]" in resp.text:
                bypasses[name] = True
            else:
                bypasses[name] = False
        else:
            bypasses[name] = False
    
    return bypasses
